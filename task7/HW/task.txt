7-я домашка посвящена мультиплексированию ввода-вывода.
Предлагается разработать программное решение, реализующее в себе архитектуру "клиент-сервер". Данный тип архитектуры часто используется в организации сетевого взаимодействия программ. В виду того, что сеть мы ещё не прошли, в нашем примере взаимодействие организуется в рамках одного компьютера, и компоненты общаются между собой не средствами TCP/IP стека Linux, а через FIFO.

Программа делится на 2 части: 
1) Клиент (Cn) - отправляет серверу запрос на регистрацию себя на нём, после чего имеет возможность скачивать файлы через сервер
2) Сервер (S) - регистрирует клиент, после чего отдаёт соответствующий файл по запросу

Рассмотрим схему:
1.Регистрация клиента происходит отправкой сообщения через специальное командное IPC (это может быть FIFO или очередь сообщений).
Команда регистрации содержит 3 токена: REGISTER <fifo/tx/path> <fifo/rx/path>  - команда и пути к fifo-записям на ФС для передачи команд на скачивание / скачивания файлов соответственно. Заметим, что клиентов может быть больше одного (но немного, давайте до 64-х).
Сервер отвечает "ACK" клиенту по обратному каналу связи выбранного IPC, сохраняет данные и открывает 2 FIFO для взаимодействия с ним.
! FIFO на сервере следует открывать в O_RDWR-режиме (подробнее здесь: https://stackoverflow.com/questions/14594508/fifo-pipe-is-always-readable-in-select)

CMD INTERFACE:
    REGISTER <file/tx/path> <fifo/rx/path>
(Cx) --------------------------------------> (S): open(fromclient_tx_fifo_fd, O_RDWR), open(fromclient_rx_fifo_fd, O_RDWR), then:
   <------------------ACK-------------------
   
2. Далее любой подключённый клиент может запросить у сервера файл командой GET <filename> по своему TX, сервер обязан определить, какой клиент это сделал, и отправить его по клиентскому RX-каналу. Список файлов известен клиенту и серверу, так что можно забить статически.

REQUEST-RESPONSE WORKFLOW:
          GET <filname>                       (S):
(Cx) --------------------------------------> |fromclient_tx_fifo_fd|
   <------------------file------------------ |fromclient_rx_fifo_fd|

Замечание по устройству сервера: сервер отслеживает состояние множества входящих дескрипторов через вызов select(...), определяет дескриптор, на который пришёл запрос, после чего запускает процедуру отдачи файла В ОТДЕЛЬНОМ ПОТОКЕ. Таким образом, при большом (в наших ограничениях :)) числе одновременных обращений сервер является неблокирующим. Пример использования select(...) см. в "examples/".

REQUEST-RESPONSE in more detail...:
                                                                    (S):
(C1)                                         |fromclient_tx_fifo_fd1| - \
                                             |fromclient_rx_fifo_fd1|.   \
...               request is here!                                        \
(Cx) ---------------**************---------> |fromclient_tx_fifo_fdx| -  select() --> FD_ISSET(x, &read_descr_set)==TRUE --> then-->| 
   <------------------file------------------ |fromclient_rx_fifo_fdx|. <------------------------create_thread,get_file,transmit file|
                                                .....................    /
(Cn)                                         |fromclient_tx_fifo_fdn|   /

Напишите реализацию, которая минимизирует количество системных вызовов на 1 итерацию работы сервера (в идеале О(1) от числа соединений).

(*)Задача со звёздочкой (потенциальный "плюс балл"): попробовать "переиспользовать" потоки для новых запросов/использовать "пул" подготовленных заранее потоков (! запрещается использовать стандартные библиотечные реализации пула потоков в C++ !). NB. По данному пункту буду спрашивать жестко. В дополнение, могу сослаться на код (естественно, при слаче могу заинтересоваться внутренним устройством. И не гарантирую, что он везде рабочий...): https://github.com/Pithikos/C-Thread-Pool
Footer
