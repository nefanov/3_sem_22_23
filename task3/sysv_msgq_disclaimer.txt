Мы с вами рассматриваем в данном разделе 2 из 3-х IPC, введённых и аппробированных в UNIX-подобных ОС, начиная со стандарта SYS V 3rd edition,поэтому они так и называются: SYS V IPC.
Соответственно, мы сначала пройдём Разделяемую память и Очереди сообщений. Семафоры, 3-й примитив, мы пройдём после ознакомления с таким понятием, как потоки(threads).
О разделяемой памяти мы уже успели поговорить и написать ряд примеров, поэтому повествование ниже будет сфокусировано на очередях сообщений, но характерные для них особенности SYS V IPC характерны и для двух других примитивов.
Для того, чтобы посмотреть текущие ресурсы SYS V IPC, наберите команду ipcs в Вашем терминале. Вывод будет в следующем формате:
------ Shared Memory Segments --------
   key shmid owner perms bytes nattch status
   ------ Semaphore Arrays --------
   key semid owner perms nsems status
   ------ Message Queues --------
   key msqid owner perms used-bytes messages
Из данного вывода можно заключить о характерных свойствах SYS V IPC.

Итак, на примере очередей сообщений, разберём типовые поля из вывода команды:

     * key - ключ (имя), который присваивается очереди при ее создании
       вызовом функции msgget().
     * msqid - значение, возвращаемое функцией msgget(). Является
       дескриптором очереди. Любые операции над очередью сообщений
       осуществляются с указанием этого дескриптора.
     * owner - пользователь, создавший очередь.
     * perms - восьмеричное число, определяющее права доступа к очереди.
       Очень напоминает права доступа к файлам.
     * used-bytes - текущее количество байт, хранящихся в очереди.
     * messages - количество сообщений в очереди.
     
Ключ - средство для общего доступа к некому примитиву. Каждый, кто знает его значение, сможет писать и читать данные (см. примеры с прошлого семинара). Можно сгенерировать некое целое число, которое служит ключом, и, в принципе, это годится. В случае, если нужно "скрыть" ключ, можно пользоваться макросом IPC_PRIVATE - система сама сгенерирует ключ, но никому его не отдаст. Так можно соединить связью, например, процесс-родитель и потомка, отнаследовав дескриптор на примитив, по аналогии с тем, как мы это делаем в неименованных каналах.

Схема работы с очередями сообщений-такая же, как с другими SYS V IPC: вы делаете вызов <"IPCNAME">get, создающий примитив IPC и возвращающий файловый дескриптор. С этим дескриптором уже можно работать, как с дескриптором на регулярный файл, то есть читать из него, писать, etc. Однако примитивы IPC имеют более удобный интерфейс, например, разделяемая память позволяет настроить отображение в виртуальную память процесса и получить указатель через shmat. Очереди сообщений же позволяют отправить сообщение в очередь через msgsnd, либо принять через msgrcv. 
Освободить ресурс IPC можно через характерный вызов <"IPCNAME">ctl.
Для знакомства с очередями сообщений на практике следует посмотреть примеры из директории "examples" данного примера.
Заметим, что тип отправляемого сообщения (поле .mtype) строго > 0. В msgrcv можно принимать сообщения, выставив =0, тогда будет вычитано первое сообщение из очереди, без учёта типа. mtype<0 работает куда интереснее, и позволяет реализовать приоритетную очередь:
"If msgtyp is less than 0, then the first message in the queue with the lowest type less than or equal to the absolute value of msgtyp will be read."
Также заметим, что размер отправляемого сообщения указывается без учёта поля длины (см. пример).
